/* Operators 연산자에 대해 알아보자 */

#include<iostream>
using namespace std;

int main()
{
	int x = 29; // x is a variable, 2 si a literal. =, 이거는 대입 연산자!!
	cout << "Hello world" << endl;
	cout << 1 + 2 << endl; // 1,2 is a literal, + is operater.

	return 0;

}

/*

단항 연산자 --> cout << x;

이항 연산자 --> cout << 1+2 ;

삼항 연산자 --> int y = ( x > 0 ) ? 1 : 2; True left False right. 비교 및 분기가 포함 되어 있는 연산자 이다.

*/



/*
쉽게 생각하시면 됩니다.



리터럴... 영어로 literal이란, 융통성이 없는, 엄밀한 이란 뜻을 가지고 있지요.



심볼릭은 뭔가요? symbolic은 상징적인, 기호 등의 뜻을 가지고 있습니다.



의미적으로 보면,



리터럴은 뭔가 정확하고, 엄밀한 것이고, 심볼릭은 대강의 기호 정도구나 라고 이해하시면 되겠습니다.



그럼 예를 들어보죠.



만약 시간을 입력받는 프로그램을 짠다고 가정하면, 최대 시간값은 24겠죠? (24보다 크면 에러일 것입니다)



if ( hour > 24 )  printf("ERROR");



하지만 코드에 상수를 바로 쓰는 것은 좋지않습니다. 해서 이렇게 바꾸고 이렇게 짰다고 가정합시다.



const float MAX_HOUR = 24;

float hour = MAX_HOUR;



자 이 MAX_HOUR는 리터럴 상수입니다. 정밀하고 확실한 숫자이지요.



아래처럼 하는 방법도 있겠군요.



#define MAX_HOUR 24

float hour = MAX_HOUR;



이번엔 심볼릭 상수입니다.



무슨차이죠? 하고 물으신다면, 바로 정확도의 차이입니다.

만약



int hour = 10; 이라고 했다면, 리터럴 상수로 작업하신 코드에서는 Warning이 뜰 것입니다.

내용은 대략 "당신 지금 int에 float를 넣으려고 했어!! 조심하는 게 좋을껄?"



심볼릭 상수로 작업하신 경우엔 이러한 경고가 나타나지 않을 것입니다.



리터럴 상수와 심볼릭 상수가 무엇인지 아는 것은 어렵지 않지만, 사용시에는 리터럴 상수를 사용하기를 권장합니다. 리터럴 상수를 사용하는 경우, 컴파일러가 엄격하게 타입점검을 해주지만, 심볼릭 상수의 경우, 컴파일러가 타입점검을 제대로 해주지 않습니다.

*/